// integrations/htaccess/index.ts
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import type { AstroIntegration } from 'astro';
import yaml from 'js-yaml';

interface RedirectRule {
  from: string;
  to: string;
  code?: 301 | 302;
}

interface RewriteRule {
  condition?: string;
  rule: string;
  flags: string;
}

interface CacheRule {
  type: string;
  duration: string;
}

interface HtaccessConfig {
  enabled?: boolean;
  forceHttps?: boolean;
  forceWww?: 'add' | 'remove' | false;
  domain?: string;
  redirects?: RedirectRule[];
  rewrites?: RewriteRule[];
  caching?: {
    enabled?: boolean;
    rules?: CacheRule[];
  };
  compression?: {
    gzip?: boolean;
    brotli?: boolean;
  };
  cors?: {
    fonts?: boolean;
    images?: boolean;
    origins?: string[];
    allowCredentials?: boolean;
    allowedMethods?: string[];
    allowedHeaders?: string[];
  };
  spaFallback?: boolean;
  customRules?: string;
}

export default function generateHtaccess({
  config: configPath = 'src/htaccess',
}: {
  config: HtaccessConfig;
}): AstroIntegration {
  let htaccessConfig: HtaccessConfig = {};

  return {
    name: 'generate-htaccess',

    hooks: {
      'astro:config:setup': async ({ config, logger, addWatchFile }) => {
        const buildLogger = logger.fork('htaccess');

        // Carrega configuração
        try {
          const configFile = new URL(configPath, config.root);
          const configContent = fs.readFileSync(
            fileURLToPath(configFile),
            'utf8'
          );

          // tenta YAML SEMPRE
          try {
            htaccessConfig = yaml.load(configContent) as HtaccessConfig;
            buildLogger.info(`Config carregada como YAML (${configPath})`);
          } catch {
            // fallback → tenta JSON
            htaccessConfig = JSON.parse(configContent);
            buildLogger.info(`Config carregada como JSON (${configPath})`);
          }

          addWatchFile(configFile);
        } catch (error) {
          buildLogger.warn(
            `Arquivo ${configPath} não encontrado. Usando padrão.`
          );
          htaccessConfig = getDefaultConfig();
        }
      },

      'astro:build:done': async ({ dir, logger }) => {
        const buildLogger = logger.fork('htaccess');

        if (htaccessConfig.enabled === false) {
          buildLogger.info(
            'Geração de .htaccess desabilitada na configuração.'
          );
          return;
        }

        const outDir = fileURLToPath(dir);
        const htaccessPath = path.join(outDir, '.htaccess');

        buildLogger.info(`Gerando .htaccess em ${htaccessPath}...`);

        try {
          const content = buildHtaccessContent(htaccessConfig);
          fs.writeFileSync(htaccessPath, content, 'utf8');
          buildLogger.info('✓ .htaccess gerado com sucesso!');
        } catch (error) {
          buildLogger.error(`Erro ao gerar .htaccess: ${error}`);
        }
      },
    },
  };
}

function getDefaultConfig(): HtaccessConfig {
  return {
    enabled: true,
    forceHttps: true,
    forceWww: 'remove',
    redirects: [],
    caching: { enabled: true },
    compression: { gzip: true, brotli: true },
    cors: { fonts: true },
    spaFallback: false,
  };
}

function buildHtaccessContent(config: HtaccessConfig): string {
  const sections: string[] = [];

  // Header
  sections.push(`# Auto-generated by Astro htaccess plugin
# Last updated: ${new Date().toISOString()}
`);

  // HTTPS & WWW
  if (config.forceHttps || config.forceWww) {
    sections.push(buildHttpsWwwSection(config));
  }

  // Redirects
  if (config.redirects && config.redirects.length > 0) {
    sections.push(buildRedirectsSection(config.redirects));
  }

  // Rewrites customizados
  if (config.rewrites && config.rewrites.length > 0) {
    sections.push(buildRewritesSection(config.rewrites));
  }

  // Caching
  if (config.caching?.enabled) {
    sections.push(buildCachingSection(config.caching.rules));
  }

  // Compression
  if (config.compression?.gzip || config.compression?.brotli) {
    sections.push(buildCompressionSection(config.compression));
  }

  // CORS
  if (config.cors?.fonts || config.cors?.images || config.cors?.origins) {
    sections.push(buildCorsSection(config.cors));
  }

  // SPA Fallback
  if (config.spaFallback) {
    sections.push(buildSpaFallbackSection());
  }

  // Regras customizadas
  if (config.customRules) {
    sections.push(`# ------------------------------------------------------
# CUSTOM RULES
# ------------------------------------------------------
${config.customRules}
`);
  }

  return sections.join('\n');
}

function buildHttpsWwwSection(config: HtaccessConfig): string {
  const lines = [
    `# ------------------------------------------------------
# FORCE HTTPS & WWW CONFIGURATION
# ------------------------------------------------------
RewriteEngine On
`,
  ];

  if (config.forceWww === 'remove' && config.domain) {
    lines.push(`# Redirect www → non-www
RewriteCond %{HTTP_HOST} ^www\\.${escapeRegex(config.domain)}$ [NC]
RewriteRule ^(.*)$ https://${config.domain}/$1 [L,R=301]
`);
  } else if (config.forceWww === 'add' && config.domain) {
    lines.push(`# Redirect non-www → www
RewriteCond %{HTTP_HOST} ^${escapeRegex(config.domain)}$ [NC]
RewriteRule ^(.*)$ https://www.${config.domain}/$1 [L,R=301]
`);
  }

  if (config.forceHttps) {
    lines.push(`# Force HTTPS
RewriteCond %{HTTPS} off
RewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
`);
  }

  return lines.join('\n');
}

function buildRedirectsSection(redirects: RedirectRule[]): string {
  const lines = [
    `# ------------------------------------------------------
# URL REDIRECTS
# ------------------------------------------------------
`,
  ];

  redirects.forEach((redirect) => {
    const code = redirect.code || 301;
    lines.push(`Redirect ${code} ${redirect.from} ${redirect.to}`);
  });

  return lines.join('\n') + '\n';
}

function buildRewritesSection(rewrites: RewriteRule[]): string {
  const lines = [
    `# ------------------------------------------------------
# REWRITE RULES
# ------------------------------------------------------
RewriteEngine On
`,
  ];

  rewrites.forEach((rewrite) => {
    if (rewrite.condition) {
      lines.push(`RewriteCond ${rewrite.condition}`);
    }
    lines.push(`RewriteRule ${rewrite.rule} [${rewrite.flags}]`);
  });

  return lines.join('\n') + '\n';
}

function buildCachingSection(rules?: CacheRule[]): string {
  const defaultRules: CacheRule[] = rules || [
    { type: 'image/jpeg', duration: 'access plus 1 year' },
    { type: 'image/png', duration: 'access plus 1 year' },
    { type: 'image/webp', duration: 'access plus 1 year' },
    { type: 'image/avif', duration: 'access plus 1 year' },
    { type: 'image/svg+xml', duration: 'access plus 1 year' },
    { type: 'font/ttf', duration: 'access plus 1 year' },
    { type: 'font/woff', duration: 'access plus 1 year' },
    { type: 'font/woff2', duration: 'access plus 1 year' },
    { type: 'text/css', duration: 'access plus 1 month' },
    { type: 'application/javascript', duration: 'access plus 1 month' },
    { type: 'text/html', duration: 'access plus 1 hour' },
  ];

  const lines = [
    `# ------------------------------------------------------
# BROWSER CACHING
# ------------------------------------------------------
<IfModule mod_expires.c>
  ExpiresActive On
`,
  ];

  defaultRules.forEach((rule) => {
    lines.push(`  ExpiresByType ${rule.type} "${rule.duration}"`);
  });

  lines.push(`</IfModule>
`);

  return lines.join('\n');
}

function buildCompressionSection(
  compression: NonNullable<HtaccessConfig['compression']>
): string {
  const lines = [
    `# ------------------------------------------------------
# COMPRESSION
# ------------------------------------------------------
`,
  ];

  if (compression.gzip) {
    lines.push(`<IfModule mod_deflate.c>
  AddOutputFilterByType DEFLATE text/html text/plain text/xml
  AddOutputFilterByType DEFLATE text/css application/javascript application/json
  AddOutputFilterByType DEFLATE image/svg+xml
</IfModule>
`);
  }

  if (compression.brotli) {
    lines.push(`<IfModule mod_brotli.c>
  AddOutputFilterByType BROTLI_COMPRESS text/html text/plain text/xml
  AddOutputFilterByType BROTLI_COMPRESS text/css application/javascript application/json
  AddOutputFilterByType BROTLI_COMPRESS image/svg+xml
</IfModule>
`);
  }

  return lines.join('\n');
}

function buildCorsSection(cors: NonNullable<HtaccessConfig['cors']>): string {
  const lines = [
    `# ------------------------------------------------------
# CORS CONFIGURATION
# ------------------------------------------------------
<IfModule mod_headers.c>
`,
  ];

  const allowOrigin = cors.origins?.[0] ?? '*';
  const credentials = cors.allowCredentials ? 'true' : 'false';
  const methods = cors.allowedMethods?.join(', ') ?? 'GET, POST, OPTIONS';
  const headers =
    cors.allowedHeaders?.join(', ') ??
    'Content-Type, Accept, Authorization, Origin';

  // Headers gerais
  lines.push(`  Header set Access-Control-Allow-Origin "${allowOrigin}"`);
  if (cors.allowCredentials) {
    lines.push(
      `  Header set Access-Control-Allow-Credentials "${credentials}"`
    );
  }
  lines.push(`  Header set Access-Control-Allow-Methods "${methods}"`);
  lines.push(`  Header set Access-Control-Allow-Headers "${headers}"`);
  lines.push('');

  // Fonts
  if (cors.fonts) {
    lines.push(`  # Fonts CORS
  <FilesMatch "\\.(ttf|ttc|otf|eot|woff|woff2|css)$">
    Header set Access-Control-Allow-Origin "${allowOrigin}"
    ${cors.allowCredentials ? `Header set Access-Control-Allow-Credentials "${credentials}"` : ''}
    Header set Access-Control-Allow-Methods "${methods}"
    Header set Access-Control-Allow-Headers "${headers}"
  </FilesMatch>
`);
  }

  // Images
  if (cors.images) {
    lines.push(`  # Images CORS
  <FilesMatch "\\.(avifs?|bmp|cur|gif|ico|jpe?g|jxl|png|svgz?|webp)$">
    Header set Access-Control-Allow-Origin "${allowOrigin}"
    ${cors.allowCredentials ? `Header set Access-Control-Allow-Credentials "${credentials}"` : ''}
    Header set Access-Control-Allow-Methods "${methods}"
    Header set Access-Control-Allow-Headers "${headers}"
  </FilesMatch>
`);
  }

  // Múltiplas origens suportadas
  if (cors.origins && cors.origins.length > 1) {
    const originsPattern = cors.origins.map((o) => escapeRegex(o)).join('|');

    lines.push(`  # Multiple origins support
  SetEnvIf Origin "^(${originsPattern})$" ORIGIN=$0
  Header set Access-Control-Allow-Origin "%{ORIGIN}e" env=ORIGIN
`);
  }

  lines.push(`</IfModule>
`);
  return lines.join('\n');
}

function buildSpaFallbackSection(): string {
  return `# ------------------------------------------------------
# SPA FALLBACK (Client-side routing)
# ------------------------------------------------------
RewriteEngine On
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule . /index.html [L]
`;
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
